# Детальное описание протокола ТЭМ-104

## Общие принципы протокола

Протокол ТЭМ-104 основан на принципе "ведущий-ведомый" (Master-Slave), где:
- **Ведущий** (Master) - ваш компьютер/контроллер
- **Ведомый** (Slave) - теплосчетчик ТЭМ-104

### Физический уровень

#### Поддерживаемые интерфейсы
| Интерфейс | Скорости передачи | Адресация |
|-----------|-------------------|-----------|
| **RS-232C** | 9600, 19200, 28800, 38400, 57600, 115200 бод | 1-32 (для одиночного устройства), 1-240 (для сети) |
| **RS-485** | 9600, 19200, 57600, 115200 бод | 1-32 (для одиночного устройства), 1-240 (для сети) |

#### Параметры связи
- **Стоп-бит**: 1
- **Бит данных**: 8
- **Контроль четности**: Нет
- **Адресация**: от 1 до 240 (0x01-0xF0)

### Поддерживаемые модели
- **ТЭМ-104** - базовая модель
- **ТЭМ-104-1** - улучшенная версия
- **ТЭМ-104М** - новая модель
- **ТЭМ-104М-1** - самая новая модель
- **ТЭМ-104 (ТЭСМАРТ)** - альтернативный производитель

## Структура пакета

### Запрос (от ведущего к ведомому)

```
[SIG][ADDR][!ADDR][CGRP][CMD][LEN][DATA...][CS]
```

| Поле | Размер | Описание | Пример |
|------|--------|----------|--------|
| SIG | 1 байт | Стартовый байт | 0x55 |
| ADDR | 1 байт | Адрес устройства | 0x01 |
| !ADDR | 1 байт | Инверсный адрес | 0xFE |
| CGRP | 1 байт | Группа команд | 0x00 |
| CMD | 1 байт | Команда | 0x00 |
| LEN | 1 байт | Длина данных | 0x00 |
| DATA | N байт | Данные (опционально) | - |
| CS | 1 байт | Контрольная сумма | 0xAB |

### Ответ (от ведомого к ведущему)

```
[SIG][ADDR][!ADDR][CGRP][CMD][LEN][DATA...][CS]
```

| Поле | Размер | Описание | Пример |
|------|--------|----------|--------|
| SIG | 1 байт | Стартовый байт | 0xAA |
| ADDR | 1 байт | Адрес устройства | 0x01 |
| !ADDR | 1 байт | Инверсный адрес | 0xFE |
| CGRP | 1 байт | Группа команд | 0x00 |
| CMD | 1 байт | Команда | 0x00 |
| LEN | 1 байт | Длина данных | 0x08 |
| DATA | N байт | Данные | "TEM-104" |
| CS | 1 байт | Контрольная сумма | 0xXX |

## Группы команд

### 0x00 - Соединение и идентификация

| Команда | Код | Описание | Данные |
|---------|-----|----------|--------|
| Идентификация | 0x00 | Получение имени устройства | Нет |

**Пример запроса идентификации:**
```
55 01 FE 00 00 00 AB
```

**Пример ответа:**
```
AA 01 FE 00 00 08 54 45 4D 2D 31 30 34 XX
```
(где 54 45 4D 2D 31 30 34 = "TEM-104" в ASCII)

### 0x0F - Чтение памяти (EEPROM)

| Команда | Код | Описание | Данные |
|---------|-----|----------|--------|
| Чтение конфигурации | 0x01 | Чтение итоговых данных | [ADDR_H][ADDR_L][LEN] |
| Чтение времени | 0x02 | Чтение RTC | [ADDR_H][ADDR_L][LEN] |
| Чтение архива | 0x03 | Чтение архивных записей | [ADDR_H][ADDR_L][LEN] |

**Структура данных запроса:**
- **ADDR_H** (1 байт) - старший байт адреса
- **ADDR_L** (1 байт) - младший байт адреса  
- **LEN** (1 байт) - длина читаемого блока

**Пример чтения итогов (адрес 0x0180, длина 0xFF):**
```
55 01 FE 0F 01 03 01 80 FF XX
```

### 0x0C - Чтение ОЗУ (RAM)

| Команда | Код | Описание | Данные |
|---------|-----|----------|--------|
| Чтение мгновенных параметров | 0x01 | Чтение RAM | [ADDR_H][ADDR_L][LEN] |

**Пример чтения мгновенных параметров (адрес 0x4000, длина 0xFF):**
```
55 01 FE 0C 01 03 40 00 FF XX
```

### 0x0D - Дополнительные команды

| Команда | Код | Описание | Данные |
|---------|-----|----------|--------|
| Чтение архива по дате | 0x11 | Чтение архивных записей по дате | [START_DATE][END_DATE][ARCHIVE_TYPE] |

### 0x8F / 0x8C / 0x8D - Расширенные команды

Команды с префиксом 0x8 позволяют читать блоки данных размером более 256 байт:
- **0x8F01** - Расширенное чтение конфигурации
- **0x8C01** - Расширенное чтение мгновенных параметров  
- **0x8F03** - Расширенное чтение архива
- **0x8D11** - Расширенное чтение архива по дате

## Контрольная сумма

Контрольная сумма рассчитывается как **инвертированная сумма всех байтов пакета** (кроме самой контрольной суммы).

**Алгоритм расчета:**
```python
def calculate_checksum(packet):
    """Рассчитывает контрольную сумму для пакета ТЭМ-104."""
    return (~sum(packet) & 0xFF)
```

**Пример:**
- Пакет: `55 01 FE 00 00 00`
- Сумма: `0x55 + 0x01 + 0xFE + 0x00 + 0x00 + 0x00 = 0x154`
- Младший байт: `0x54`
- Инвертированный: `~0x54 & 0xFF = 0xAB`

## Адресация памяти для разных моделей

### ARVAS_M1 (TEM-104M-1)

| Тип данных | Адрес | Размер | Описание |
|------------|-------|--------|----------|
| Итоги | 0x0180 | 0xFF | Накопленные значения |
| Мгновенные | 0x4000 | 0xFF | Текущие параметры |
| Время | 0x0000 | 0x07 | RTC (десятичный формат) |
| Архив | 0x0182 | Переменный | Архивные записи |

**Смещения в блоке итогов (0x0180):**
- `0x08-0x0B`: V1 (Объем 1, float)
- `0x0C-0x0F`: M1 (Масса 1, float)  
- `0x10-0x13`: Q (Энергия, float)
- `0x18-0x1B`: V1 (Объем 1, long)
- `0x1C-0x1F`: M1 (Масса 1, long)
- `0x20-0x23`: Q (Энергия, long)
- `0x30-0x33`: T_nar (Наработка, long)

**Смещения в блоке мгновенных (0x4000):**
- `0x00-0x03`: T1 (Температура 1, float)
- `0x04-0x07`: T2 (Температура 2, float)
- `0x20-0x23`: G1 (Расход 1, float)
- `0x24-0x27`: G2 (Расход 2, float)

### ARVAS_LEGACY (TEM-104)

| Тип данных | Адрес | Размер | Описание |
|------------|-------|--------|----------|
| Итоги | 0x0200 | 0xFF | Накопленные значения |
| Мгновенные | 0x2200 | 0xFF | Текущие параметры |
| Время | 0x0010 | 0x0A | RTC (BCD формат) |
| Архив | 0x0200 | Переменный | Архивные записи |

**Смещения в блоке итогов (0x0200):**
- `0x08-0x0B`: V1 (Объем 1, float)
- `0x0C-0x0F`: V2 (Объем 2, float)
- `0x18-0x1B`: M1 (Масса 1, float)
- `0x28-0x2B`: Q (Энергия, float)
- `0x38-0x3B`: V1 (Объем 1, long)
- `0x3C-0x3F`: V2 (Объем 2, long)
- `0x48-0x4B`: M1 (Масса 1, long)
- `0x58-0x5B`: Q (Энергия, long)
- `0x6C-0x6F`: T_nar (Наработка, long)

**Смещения в блоке мгновенных (0x2200):**
- `0x00-0x03`: T1 (Температура 1, float)
- `0x04-0x07`: T2 (Температура 2, float)
- `0x40-0x43`: G1 (Расход 1, float)
- `0x44-0x47`: G2 (Расход 2, float)

### TESMART (ТЭСМАРТ)

| Тип данных | Адрес | Размер | Описание |
|------------|-------|--------|----------|
| Конфигурация | 0x0000-0x04FF | 0xFF | Полная конфигурация (5 блоков по 256 байт) |
| Время | Встроено в конфигурацию | BCD | RTC в BCD формате |
| Итоги | Встроены в конфигурацию | Переменный | Накопленные значения с коэффициентами |
| Мгновенные | Встроены в конфигурацию | Переменный | Текущие параметры |

**Особенности TESMART:**
- Все данные читаются одним большим блоком (5 × 256 байт)
- Требуется разбор коэффициентов для пересчета итогов
- Время хранится в BCD формате встроенно в конфигурацию

## Форматы данных

### Порядок байтов (Endianness)
Все многобайтовые данные (Int, Long, Float) передаются в формате **Motorola (Big-Endian)**, то есть старший байт идет первым (MSB → LSB). При работе на PC (процессоры Intel, Little-Endian) необходимо использовать соответствующие функции преобразования.

### Float (4 байта)
Числа с плавающей точкой хранятся в формате IEEE 754, big-endian.

```python
import struct

# Чтение float из 4 байт (Big-Endian)
def read_float(data, offset):
    return struct.unpack('>f', data[offset:offset+4])[0]

# Пример
data = b'\x42\xC8\x00\x00'  # 100.0 в IEEE 754
temp = read_float(data, 0)   # temp = 100.0
```

### Long (4 байта)
32-битные целые числа в big-endian формате.

```python
# Чтение long из 4 байт (Big-Endian)
def read_long(data, offset):
    return struct.unpack('>L', data[offset:offset+4])[0]

# Пример
data = b'\x00\x00\x00\x64'  # 100 в десятичной системе
value = read_long(data, 0)   # value = 100
```

### BCD (Binary Coded Decimal)
Время в старых моделях хранится в BCD формате.

```python
def bcd_to_int(bcd_byte):
    """Преобразует один байт BCD в integer."""
    return (bcd_byte >> 4) * 10 + (bcd_byte & 0x0F)

# Пример
bcd_byte = 0x34  # BCD код для 34
value = bcd_to_int(bcd_byte)  # value = 34
```

### Unix Timestamp (для ТЭМ-104М)
Новые модели (ТЭМ-104М, ТЭМ-104М-1) используют Unix timestamp для хранения времени.

```python
import time

def read_unix_timestamp(data, offset):
    """Чтение Unix timestamp из 4 байт."""
    timestamp = struct.unpack('>L', data[offset:offset+4])[0]
    return time.gmtime(timestamp)  # UTC время

# Пример
data = b'\x00\x00\x01\x23'  # Unix timestamp
dt = read_unix_timestamp(data, 0)
print(f"Время: {time.strftime('%Y-%m-%d %H:%M:%S', dt)}")
```

## Примеры полных диалогов

### Пример 1: Идентификация устройства

**Запрос:**
```
55 01 FE 00 00 00 AB
```

**Ответ:**
```
AA 01 FE 00 00 08 54 45 4D 2D 31 30 34 XX
```
(где XX - контрольная сумма)

### Пример 2: Чтение времени (ARVAS_M1)

**Запрос:**
```
55 01 FE 0F 02 02 00 07 XX
```

**Ответ:**
```
AA 01 FE 0F 02 06 12 34 56 01 06 24 XX
```
(где 12 34 56 01 06 24 = время 12:34:56 01.06.2024)

### Пример 3: Чтение итогов (ARVAS_M1)

**Запрос:**
```
55 01 FE 0F 01 03 01 80 FF XX
```

**Ответ:**
```
AA 01 FE 0F 01 FF [255 байт данных] XX
```

### Пример 4: Чтение архива (ARVAS_M1)

**Запрос:**
```
55 01 FE 0F 03 03 01 82 FF XX
```

**Ответ:**
```
AA 01 FE 0F 03 FF [255 байт архивных данных] XX
```

### Пример 5: Расширенное чтение (более 256 байт)

**Запрос:**
```
55 01 FE 8F 01 03 01 80 00 XX
```

**Ответ:**
```
AA 01 FE 8F 01 00 [256 байт данных] XX
```

### Пример 6: Чтение архива по дате

**Запрос:**
```
55 01 FE 0D 11 06 [START_DATE][END_DATE][ARCHIVE_TYPE] XX
```

**Ответ:**
```
AA 01 FE 0D 11 [LEN] [архивные данные] XX
```

## Подробное описание команд

### Команды идентификации и конфигурации

#### 0x0000 - Идентификация устройства
- **Назначение**: Получение имени устройства для определения модели
- **Данные**: Нет
- **Ответ**: ASCII-строка с именем устройства
- **Примеры ответов**:
  - `"TEM-104"` - базовая модель
  - `"TEM-104-1"` - улучшенная версия
  - `"TEM-104M"` - новая модель
  - `"TEM-104M-1"` - самая новая модель
  - `"TSM104"` - ТЭСМАРТ

### Команды чтения данных

#### 0x0F01 - Чтение конфигурации (итоговые данные)
- **Назначение**: Чтение накопленных итогов и конфигурации
- **Данные**: [ADDR_H][ADDR_L][LEN]
- **Размер блока**: 256 байт (0xFF) или 512 байт (0x00)
- **Содержимое**: Накопленные итоги, конфигурация, системные параметры

#### 0x0F02 - Чтение времени (RTC)
- **Назначение**: Получение текущего времени счетчика
- **Данные**: [ADDR_H][ADDR_L][LEN]
- **Формат времени**:
  - **ТЭМ-104/104-1**: BCD формат
  - **ТЭМ-104М/104М-1**: Десятичный формат
  - **ТЭСМАРТ**: BCD формат (встроено в конфигурацию)

#### 0x0F03 - Чтение архива
- **Назначение**: Чтение архивных записей
- **Данные**: [ADDR_H][ADDR_L][LEN]
- **Размер записи**: Зависит от модели
- **Содержимое**: Исторические данные с временными метками

#### 0x0C01 - Чтение мгновенных параметров
- **Назначение**: Получение текущих значений (температуры, расходы)
- **Данные**: [ADDR_H][ADDR_L][LEN]
- **Содержимое**: Мгновенные параметры в реальном времени

### Расширенные команды

#### 0x8F01 - Расширенное чтение конфигурации
- **Назначение**: Чтение блоков данных размером более 256 байт
- **Особенность**: Префикс 0x8 позволяет читать большие блоки
- **Использование**: Для моделей с большими объемами конфигурации

#### 0x8C01 - Расширенное чтение мгновенных параметров
- **Назначение**: Чтение расширенных мгновенных параметров
- **Применение**: Для моделей с дополнительными датчиками

#### 0x8F03 - Расширенное чтение архива
- **Назначение**: Чтение больших архивных блоков
- **Использование**: Для получения исторических данных

#### 0x0D11 - Чтение архива по дате
- **Назначение**: Выборочное чтение архивных записей по временному диапазону
- **Данные**: [START_DATE][END_DATE][ARCHIVE_TYPE]
- **Применение**: Для анализа исторических данных за период

## Обработка ошибок

### Типичные ошибки

1. **Нет ответа**
   - Причина: Неправильный адрес, скорость или подключение
   - Решение: Проверить настройки и физическое подключение

2. **Неверная контрольная сумма**
   - Причина: Помехи в линии связи
   - Решение: Проверить качество соединения, экранирование

3. **Неверный стартовый байт**
   - Причина: Синхронизация, помехи
   - Решение: Сбросить буфер, повторить запрос

4. **Неверная длина данных**
   - Причина: Обрыв связи во время передачи
   - Решение: Увеличить таймаут, повторить запрос

### Рекомендации по надежности

1. **Таймауты**: Использовать таймауты 2-5 секунд
2. **Повторы**: Повторять запросы при ошибках (до 3 раз)
3. **Паузы**: Делать паузы между запросами (100-500 мс)
4. **Буферы**: Очищать буферы перед каждым запросом

## Практические рекомендации по реализации

### Архитектура системы

#### Уровень 1: Драйвер связи (TemDriver)
```python
class TemDriver:
    """Базовый драйвер для работы с COM-портом"""
    def __init__(self, port, baudrate=9600, timeout=2):
        self.port = port
        self.baudrate = baudrate
        self.timeout = timeout
        self.ser = None
    
    def connect(self):
        """Подключение к COM-порту"""
        pass
    
    def disconnect(self):
        """Отключение от COM-порта"""
        pass
    
    def _send_and_receive(self, packet):
        """Отправка пакета и получение ответа"""
        pass
```

#### Уровень 2: Протокол-специфичные классы
```python
class Tem104Protocol:
    """Протокол для ТЭМ-104/104-1/ТЭСМАРТ"""
    def read_config(self):
        """Чтение конфигурации"""
        pass
    
    def read_current_values(self):
        """Чтение мгновенных параметров"""
        pass
    
    def read_archive_record(self, record_number, archive_type):
        """Чтение архивной записи"""
        pass

class Tem104MProtocol:
    """Протокол для ТЭМ-104М/104М-1"""
    def read_config(self):
        """Чтение конфигурации"""
        pass
    
    def read_current_values(self):
        """Чтение мгновенных параметров"""
        pass
    
    def read_archive_record(self, record_number, archive_type):
        """Чтение архивной записи"""
        pass
```

#### Уровень 3: Универсальный интерфейс
```python
class Tem104Interface:
    """Универсальный интерфейс для работы с ТЭМ-104"""
    def __init__(self, driver, address):
        self.driver = driver
        self.address = address
        self.protocol = None
    
    def identify_device(self):
        """Идентификация устройства и выбор протокола"""
        pass
    
    def get_device_config(self):
        """Получение конфигурации устройства"""
        pass
    
    def get_current_data(self):
        """Получение текущих данных"""
        pass
    
    def get_archive_data(self, start_date, end_date, archive_type):
        """Получение архивных данных за период"""
        pass
```

### Алгоритм работы с устройством

#### Шаг 1: Идентификация устройства
1. Отправить команду идентификации (0x0000)
2. Получить ASCII-ответ с именем устройства
3. Определить модель по ответу
4. Выбрать соответствующий протокол

#### Шаг 2: Чтение конфигурации
1. Отправить команду чтения конфигурации (0x0F01)
2. Получить блок данных (256 или 512 байт)
3. Разобрать данные согласно структуре модели
4. Извлечь накопленные итоги и системные параметры

#### Шаг 3: Чтение мгновенных параметров
1. Отправить команду чтения мгновенных параметров (0x0C01)
2. Получить блок данных с текущими значениями
3. Разобрать температуры, расходы, мощности
4. Применить калибровочные коэффициенты

#### Шаг 4: Чтение архива (опционально)
1. Определить размер архивной записи для модели
2. Отправить команду чтения архива (0x0F03)
3. Получить архивные данные с временными метками
4. Разобрать исторические данные

### Обработка данных

#### Преобразование форматов
```python
def convert_data_formats(data, source_format, target_format):
    """Преобразование данных между форматами"""
    if source_format == 'Motorola' and target_format == 'Intel':
        # Преобразование Big-Endian в Little-Endian
        return data[::-1]
    return data

def parse_bcd_time(bcd_data):
    """Разбор времени в BCD формате"""
    seconds = bcd_to_int(bcd_data[0])
    minutes = bcd_to_int(bcd_data[1])
    hours = bcd_to_int(bcd_data[2])
    day = bcd_to_int(bcd_data[3])
    month = bcd_to_int(bcd_data[4])
    year = 2000 + bcd_to_int(bcd_data[5])
    return datetime(year, month, day, hours, minutes, seconds)

def parse_unix_timestamp(timestamp_data):
    """Разбор Unix timestamp"""
    timestamp = struct.unpack('>L', timestamp_data)[0]
    return time.gmtime(timestamp)
```

#### Валидация данных
```python
def validate_response(response):
    """Проверка корректности ответа"""
    if not response or len(response) < 6:
        return False
    
    if response[0] != 0xAA:
        return False
    
    if calculate_checksum(response[:-1]) != response[-1]:
        return False
    
    return True

def validate_data_range(value, min_val, max_val, parameter_name):
    """Проверка диапазона значений"""
    if not (min_val <= value <= max_val):
        print(f"Предупреждение: {parameter_name} = {value} вне диапазона [{min_val}, {max_val}]")
        return False
    return True
```

## Оптимизация производительности

### Для массового опроса

1. **Параллельные запросы**: Использовать многопоточность
2. **Кэширование**: Кэшировать результаты на короткое время
3. **Приоритизация**: Сначала опрашивать критичные устройства
4. **Адаптивные таймауты**: Увеличивать таймауты при ошибках

### Для мониторинга в реальном времени

1. **Селективные запросы**: Запрашивать только нужные данные
2. **Сжатие данных**: Использовать дельта-кодирование
3. **Буферизация**: Буферизовать данные перед отправкой
4. **Сжатие времени**: Адаптировать частоту опроса к изменениям

## Заключение

Протокол ТЭМ-104 представляет собой универсальный стандарт для обмена данными с теплосчетчиками различных производителей. Несмотря на кажущуюся простоту, он требует внимания к деталям при реализации.

### Ключевые принципы успешной работы:

- ✅ **Правильная структура пакетов** - соблюдение формата запроса/ответа
- ✅ **Корректный расчет контрольной суммы** - проверка целостности данных
- ✅ **Учет особенностей разных моделей** - правильная адресация и разбор данных
- ✅ **Надежная обработка ошибок** - таймауты, повторы, валидация
- ✅ **Оптимизация для конкретных задач** - выбор подходящих команд и стратегий

### Поддерживаемые модели и их особенности:

| Модель | Протокол | Особенности |
|--------|----------|-------------|
| **ТЭМ-104** | ARVAS_LEGACY | BCD время, старые адреса |
| **ТЭМ-104-1** | ARVAS_LEGACY_1 | Улучшенная версия базовой модели |
| **ТЭМ-104М** | ARVAS_M | Десятичное время, новые адреса |
| **ТЭМ-104М-1** | ARVAS_M1 | Самая новая модель с расширенными возможностями |
| **ТЭМ-104 (ТЭСМАРТ)** | TESMART | Большие блоки данных, коэффициенты |

### Рекомендации по разработке:

1. **Начинайте с идентификации** - всегда определяйте модель устройства
2. **Используйте модульную архитектуру** - разделяйте драйвер, протокол и интерфейс
3. **Валидируйте данные** - проверяйте диапазоны и корректность
4. **Логируйте ошибки** - ведите подробные журналы для отладки
5. **Тестируйте на реальном оборудовании** - симуляция не заменяет реальные условия

### Перспективы развития:

- 🔄 **Интеграция с IoT платформами** - подключение к облачным сервисам
- 📊 **Расширенная аналитика** - машинное обучение для прогнозирования
- 🔗 **Стандартизация протоколов** - унификация с другими системами
- 🚀 **Высокоскоростные интерфейсы** - поддержка Ethernet и Wi-Fi

Успешная работа с протоколом ТЭМ-104 требует как теоретических знаний, так и практического опыта отладки. Данная документация предоставляет полную информацию для разработки надежных систем мониторинга теплоснабжения. 