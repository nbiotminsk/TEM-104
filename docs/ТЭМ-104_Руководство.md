# Книга о ТЭМ-104: Пошаговое руководство для начинающих

Добро пожаловать! Это руководство поможет вам научиться "разговаривать" с теплосчетчиками серии ТЭМ-104 на их родном языке — языке протокола обмена. Мы пройдем весь путь с нуля, с простыми объяснениями и живыми примерами кода.

## Глава 1: Как происходит общение?

Представьте, что вы хотите получить данные с прибора. Вы не можете просто так взять и спросить: "Эй, какая температура?". Прибор вас не поймет. Общение происходит по строгим правилам через специальный порт (чаще всего RS-485 или RS-232).

Процесс похож на радиосвязь:
1. **Вы (ведущий)**: Формируете четко структурированный вопрос — пакет с командой.
2. **Вы (ведущий)**: Отправляете этот пакет прибору.
3. **Прибор (ведомый)**: Получает ваш пакет, выполняет команду.
4. **Прибор (ведомый)**: Формирует такой же структурированный ответ — пакет с данными — и отправляет его вам.

Наша главная задача — научиться правильно составлять эти "вопросы" и правильно читать "ответы".

## Глава 2: Наш первый диалог. Команда "Ты на связи?"

Прежде чем запрашивать что-то серьезное, давайте просто убедимся, что прибор нас слышит. Для этого есть специальная команда — команда идентификации.

### Шаг 1: Собираем наш "вопрос" (пакет)

Любой пакет, который мы отправляем, состоит из нескольких частей, как конструктор:

| Часть пакета | Пример (HEX) | Описание |
|--------------|--------------|----------|
| Начало (SIG) | 55 | Флажок, который говорит: "Внимание, я начинаю передачу!" |
| Адрес (ADDR) | 01 | Номер прибора в сети (от 1 до 240). У каждого прибора он свой. |
| Инверсный адрес (!ADDR) | FE | Тот же адрес, но все биты инвертированы. Защита от ошибок. |
| Группа команд (CGRP) | 00 | Для команды "Ты на связи?" это всегда 00. |
| Команда (CMD) | 00 | Для команды "Ты на связи?" это всегда 00. |
| Длина данных (LEN) | 00 | Мы не передаем никаких данных, поэтому длина 0. |
| Контрольная сумма (CS) | AB | "Магическое" число для проверки, что пакет дошел без искажений. |

**Как посчитать контрольную сумму (CS)?** Это просто! Сложите все байты пакета (от SIG до LEN), а от полученной суммы возьмите только младший байт и инвертируйте его.

**Пример для адреса 1**: 55 + 01 + FE + 00 + 00 + 00 = 154 (в HEX). Младший байт 54. Инвертируем его и получаем AB.

### Шаг 2: Отправляем пакет и слушаем ответ

Когда мы отправим наш пакет, прибор должен ответить. Его ответ тоже будет в "конверте":

| Часть пакета | Пример (HEX) | Описание |
|--------------|--------------|----------|
| Начало (SIG) | AA | Ответ всегда начинается с AA. |
| Адрес (ADDR) | 01 | Адрес прибора, который отвечает. |
| Инверсный адрес (!ADDR) | FE | Его инверсный адрес. |
| ...и так далее | ... | ... |
| Данные (DATA) | 54 45 4D ... | А вот тут самое интересное - имя прибора! |

Если мы получили ответ, начинающийся с AA и с правильным адресом, — ура, связь есть!

## Шаг за шагом в коде

Ниже два примера: один на Python для реальной работы с портом, и второй на React, который имитирует этот процесс в веб-интерфейсе.

### Пример 1: Python (реальная работа с портом)

```python
import serial
import time
import sys

# --- Функции для работы с протоколом ---

def calculate_checksum(packet):
    """Рассчитывает контрольную сумму для пакета ТЭМ-104."""
    return (~sum(packet) & 255)

def create_request(address, command_group, command, data=None):
    """Создает полный пакет запроса."""
    if data is None:
        data = []
    
    # Инвертируем адрес
    inv_address = ~address & 255
    
    # Формируем базовый пакет
    packet = [0x55, address, inv_address, command_group, command, len(data)]
    packet.extend(data)
    
    # Добавляем контрольную сумму
    packet.append(calculate_checksum(packet))
    
    return bytearray(packet)

def parse_response(response_bytes):
    """Разбирает ответ от прибора и проверяет его корректность."""
    if not response_bytes or response_bytes[0] != 0xAA:
        print("Ошибка: Неверный стартовый байт ответа или ответ пуст.")
        return None

    # Проверяем контрольную сумму
    expected_cs = calculate_checksum(response_bytes[:-1])
    received_cs = response_bytes[-1]

    if expected_cs != received_cs:
        print(f"Ошибка: Неверная контрольная сумма! Ожидали: {expected_cs:02X}, получили: {received_cs:02X}")
        return None
        
    address = response_bytes[1]
    length = response_bytes[5]
    data = response_bytes[6:-1]

    if len(data) != length:
        print("Ошибка: Фактическая длина данных не совпадает с заявленной в пакете.")
        return None

    return {
        "address": address,
        "command_group": response_bytes[3],
        "command": response_bytes[4],
        "length": length,
        "data": data
    }

# --- Главная функция ---

def main():
    # ЗАМЕНИТЕ 'COM3' на ваш порт, а 1 на адрес вашего прибора
    # Для Linux/macOS порт может выглядеть как '/dev/ttyUSB0'
    try:
        PORT = 'COM3'
        BAUDRATE = 9600
        DEVICE_ADDRESS = 1
    except IndexError:
        print("Использование: python script.py <PORT> <BAUDRATE> <ADDRESS>")
        return

    try:
        # Открываем COM-порт
        ser = serial.Serial(PORT, int(BAUDRATE), timeout=2)
        print(f"Порт {PORT} открыт, скорость {BAUDRATE}.")
    except serial.SerialException as e:
        print(f"Ошибка: Не удалось открыть порт {PORT}. {e}")
        return

    # --- ШАГ 1: Идентификация устройства ---
    print("\n--- Шаг 1: Отправка команды идентификации (00 00) ---")
    
    # Создаем запрос
    request_packet = create_request(DEVICE_ADDRESS, 0x00, 0x00)
    print(f"Отправляем пакет: {' '.join(f'{b:02X}' for b in request_packet)}")

    # Отправляем и читаем ответ
    ser.write(request_packet)
    time.sleep(0.5) # Даем прибору время на ответ
    response_bytes = ser.read(128) # Читаем до 128 байт

    if not response_bytes:
        print("!!! Устройство не ответило. Проверьте подключение, адрес и скорость.")
        ser.close()
        return
        
    print(f"Получен ответ: {' '.join(f'{b:02X}' for b in response_bytes)}")

    # --- ШАГ 2: Разбор ответа и определение модели ---
    print("\n--- Шаг 2: Разбор ответа ---")
    parsed = parse_response(response_bytes)

    if parsed:
        print("Ответ корректен! Контрольная сумма верна.")
        try:
            # Декодируем данные (имя прибора) из ASCII
            device_name = parsed["data"].decode('ascii')
            print(f"Имя устройства: {device_name}")
            
            if "M" in device_name:
                print("Определен протокол: ТЭМ-104М (новый)")
            else:
                print("Определен протокол: ТЭМ-104 (старый)")
        except UnicodeDecodeError:
            print("Не удалось декодировать имя устройства.")
    else:
        print("!!! Получен некорректный ответ от устройства.")

    # Закрываем порт
    ser.close()
    print(f"\nПорт {PORT} закрыт.")

if __name__ == "__main__":
    main()
```

### Пример 2: Использование вашей библиотеки

```python
from test104 import TEM104_Serial_Client

def simple_identification():
    """Простой пример идентификации устройства с использованием вашей библиотеки."""
    
    # Создаем клиент для COM-порта
    client = TEM104_Serial_Client(
        port='COM3',      # Ваш COM-порт
        baudrate=9600,    # Скорость
        address=1         # Адрес счетчика
    )
    
    try:
        # Подключаемся
        client.connect()
        print("Подключение установлено!")
        
        # Автоматически определяем протокол
        protocol = client.auto_detect_protocol()
        print(f"Определен протокол: {protocol}")
        
        # Читаем все данные
        data = client.read_all_data()
        print("\n--- Данные счетчика ---")
        print(f"Q (Энергия): {data.get('Q', '---'):.3f}")
        print(f"M1 (Масса):  {data.get('M1', '---'):.3f}")
        print(f"T1 (Темп.):  {data.get('T1', '---'):.2f} °C")
        print(f"T2 (Темп.):  {data.get('T2', '---'):.2f} °C")
        print(f"G1 (Расход): {data.get('G1', '---'):.3f} м³/ч")
        
    except Exception as e:
        print(f"Ошибка: {e}")
    finally:
        client.disconnect()
        print("Соединение закрыто.")

if __name__ == "__main__":
    simple_identification()
```

## Глава 3: Чтение данных - команды для получения информации

Теперь, когда мы знаем, что прибор нас слышит, давайте научимся читать реальные данные.

### Основные группы команд

| Группа | Код | Назначение |
|--------|-----|------------|
| 0x00 | 00 | Соединение и идентификация |
| 0x0F | 01 | Чтение памяти (итоговые данные) |
| 0x0F | 02 | Чтение времени (RTC) |
| 0x0C | 01 | Чтение ОЗУ (мгновенные параметры) |

### Пример: Чтение времени

```python
def read_time_example():
    """Пример чтения времени с разных моделей ТЭМ-104."""
    
    client = TEM104_Serial_Client(port='COM3', baudrate=9600, address=1)
    
    try:
        client.connect()
        
        # Определяем протокол
        protocol = client.auto_detect_protocol()
        print(f"Протокол: {protocol}")
        
        # Читаем время в зависимости от модели
        if protocol in ['ARVAS_M', 'ARVAS_M1']:
            # Новые модели - время в десятичном формате
            packet = client._create_packet(0x0F, 0x02, b'\x00\x07')
        elif protocol == 'ARVAS_LEGACY':
            # Старые модели - время в BCD
            packet = client._create_packet(0x0F, 0x02, b'\x10\x0A')
        else:
            print("Неизвестный протокол")
            return
            
        response = client._send_and_receive(packet)
        if response:
            print(f"Время получено: {response.hex()}")
            
    finally:
        client.disconnect()
```

## Глава 4: Разбор данных - как понять, что нам ответили

### Структура данных в памяти

Разные модели ТЭМ-104 хранят данные в разных местах памяти:

#### ARVAS_M1 (TEM-104M-1)
- **Итоги**: адрес 0x0180
- **Мгновенные**: адрес 0x4000
- **Время**: десятичный формат

#### ARVAS_LEGACY (TEM-104)
- **Итоги**: адрес 0x0200  
- **Мгновенные**: адрес 0x2200
- **Время**: BCD формат

### Пример разбора данных

```python
import struct

def parse_temperature_data(raw_data, offset):
    """Разбор температуры из 4 байт (float)."""
    try:
        temp_bytes = raw_data[offset:offset+4]
        temperature = struct.unpack('>f', temp_bytes)[0]
        return temperature
    except:
        return 0.0

def parse_energy_data(raw_data, offset):
    """Разбор энергии из 4 байт (float)."""
    try:
        energy_bytes = raw_data[offset:offset+4]
        energy = struct.unpack('>f', energy_bytes)[0]
        return energy
    except:
        return 0.0

# Пример использования
raw_response = b'\x00\x00\x00\x42\x00\x00\x00\x43'  # Пример данных
temp1 = parse_temperature_data(raw_response, 0)
temp2 = parse_temperature_data(raw_response, 4)
print(f"T1: {temp1:.2f}°C, T2: {temp2:.2f}°C")
```

## Глава 5: Практические советы

### 1. Отладка связи
```python
def debug_communication():
    """Функция для отладки связи с прибором."""
    
    client = TEM104_Serial_Client(port='COM3', baudrate=9600, address=1)
    
    try:
        client.connect()
        print("✓ Порт открыт")
        
        # Тест 1: Идентификация
        protocol = client.auto_detect_protocol()
        if protocol:
            print(f"✓ Протокол определен: {protocol}")
        else:
            print("✗ Не удалось определить протокол")
            return
            
        # Тест 2: Чтение данных
        data = client.read_all_data()
        if data:
            print("✓ Данные прочитаны успешно")
            for key, value in data.items():
                print(f"  {key}: {value}")
        else:
            print("✗ Не удалось прочитать данные")
            
    except Exception as e:
        print(f"✗ Ошибка: {e}")
    finally:
        client.disconnect()
```

### 2. Проверка подключения
```python
def check_connection(port, baudrate, address):
    """Проверяет подключение к прибору."""
    
    try:
        client = TEM104_Serial_Client(port=port, baudrate=baudrate, address=address)
        client.connect()
        
        # Пробуем определить протокол
        protocol = client.auto_detect_protocol()
        if protocol:
            print(f"✓ Подключение OK! Протокол: {protocol}")
            return True
        else:
            print("✗ Прибор не отвечает на команду идентификации")
            return False
            
    except Exception as e:
        print(f"✗ Ошибка подключения: {e}")
        return False
    finally:
        client.disconnect()
```

## Заключение

Теперь вы знаете основы протокола ТЭМ-104! Вы можете:
- ✅ Формировать правильные пакеты запросов
- ✅ Отправлять команды и получать ответы
- ✅ Разбирать данные от разных моделей счетчиков
- ✅ Использовать готовую библиотеку для быстрой работы

Для дальнейшего изучения рекомендую:
1. Изучить документацию производителя вашего счетчика
2. Поэкспериментировать с разными командами
3. Написать свои функции для специфических задач

Удачи в работе с теплосчетчиками! 🔥 