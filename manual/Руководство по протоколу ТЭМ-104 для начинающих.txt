Книга о ТЭМ-104: Пошаговое руководство для начинающих
Добро пожаловать! Это руководство поможет вам научиться "разговаривать" с теплосчетчиками серии ТЭМ-104 на их родном языке — языке протокола обмена. Мы пройдем весь путь с нуля, с простыми объяснениями и живыми примерами кода.
Глава 1: Как происходит общение?
Представьте, что вы хотите получить данные с прибора. Вы не можете просто так взять и спросить: "Эй, какая температура?". Прибор вас не поймет. Общение происходит по строгим правилам через специальный порт (чаще всего RS-485 или RS-232).
Процесс похож на радиосвязь:
    1. Вы (ведущий): Формируете четко структурированный вопрос — пакет с командой.
    2. Вы (ведущий): Отправляете этот пакет прибору.
    3. Прибор (ведомый): Получает ваш пакет, выполняет команду.
    4. Прибор (ведомый): Формирует такой же структурированный ответ — пакет с данными — и отправляет его вам.
Наша главная задача — научиться правильно составлять эти "вопросы" и правильно читать "ответы".
Глава 2: Наш первый диалог. Команда "Ты на связи?"
Прежде чем запрашивать что-то серьезное, давайте просто убедимся, что прибор нас слышит. Для этого есть специальная команда — команда идентификации.
Шаг 1: Собираем наш "вопрос" (пакет)
Любой пакет, который мы отправляем, состоит из нескольких частей, как конструктор:
Часть пакета	Пример (HEX)	Описание
Начало (SIG)	55	Флажок, который говорит: "Внимание, я начинаю передачу!"
Адрес (ADDR)	01	Номер прибора в сети (от 1 до 240). У каждого прибора он свой.
Инверсный адрес (!ADDR)	FE	Тот же адрес, но все биты инвертированы. Защита от ошибок.
Группа команд (CGRP)	00	Для команды "Ты на связи?" это всегда 00.
Команда (CMD)	00	Для команды "Ты на связи?" это всегда 00.
Длина данных (LEN)	00	Мы не передаем никаких данных, поэтому длина 0.
Контрольная сумма (CS)	AB	"Магическое" число для проверки, что пакет дошел без искажений.
Как посчитать контрольную сумму (CS)? Это просто! Сложите все байты пакета (от SIG до LEN), а от полученной суммы возьмите только младший байт и инвертируйте его.
Пример для адреса 1: 55 + 01 + FE + 00 + 00 + 00 = 154 (в HEX). Младший байт 54. Инвертируем его и получаем AB.
Шаг 2: Отправляем пакет и слушаем ответ
Когда мы отправим наш пакет, прибор должен ответить. Его ответ тоже будет в "конверте":
Часть пакета	Пример (HEX)	Описание
Начало (SIG)	AA	Ответ всегда начинается с AA.
Адрес (ADDR)	01	Адрес прибора, который отвечает.
Инверсный адрес (!ADDR)	FE	Его инверсный адрес.
...и так далее	...	...
Данные (DATA)	54 45 4D ...	А вот тут самое интересное - имя прибора!
Если мы получили ответ, начинающийся с AA и с правильным адресом, — ура, связь есть!
Ша-за-шагом в коде
Ниже два примера: один на Python для реальной работы с портом, и второй на React, который имитирует этот процесс в веб-интерфейсе.
import serial
import time
import sys

# --- Функции для работы с протоколом ---

def calculate_checksum(packet):
    """Рассчитывает контрольную сумму для пакета ТЭМ-104."""
    return (~sum(packet) & 255)

def create_request(address, command_group, command, data=None):
    """Создает полный пакет запроса."""
    if data is None:
        data = []
    
    # Инвертируем адрес
    inv_address = ~address & 255
    
    # Формируем базовый пакет
    packet = [0x55, address, inv_address, command_group, command, len(data)]
    packet.extend(data)
    
    # Добавляем контрольную сумму
    packet.append(calculate_checksum(packet))
    
    return bytearray(packet)

def parse_response(response_bytes):
    """Разбирает ответ от прибора и проверяет его корректность."""
    if not response_bytes or response_bytes[0] != 0xAA:
        print("Ошибка: Неверный стартовый байт ответа или ответ пуст.")
        return None

    # Проверяем контрольную сумму
    expected_cs = calculate_checksum(response_bytes[:-1])
    received_cs = response_bytes[-1]

    if expected_cs != received_cs:
        print(f"Ошибка: Неверная контрольная сумма! Ожидали: {expected_cs:02X}, получили: {received_cs:02X}")
        return None
        
    address = response_bytes[1]
    length = response_bytes[5]
    data = response_bytes[6:-1]

    if len(data) != length:
        print("Ошибка: Фактическая длина данных не совпадает с заявленной в пакете.")
        return None

    return {
        "address": address,
        "command_group": response_bytes[3],
        "command": response_bytes[4],
        "length": length,
        "data": data
    }

# --- Главная функция ---

def main():
    # ЗАМЕНИТЕ 'COM3' на ваш порт, а 1 на адрес вашего прибора
    # Для Linux/macOS порт может выглядеть как '/dev/ttyUSB0'
    try:
        PORT = 'COM3'
        BAUDRATE = 9600
        DEVICE_ADDRESS = 1
    except IndexError:
        print("Использование: python script.py <PORT> <BAUDRATE> <ADDRESS>")
        return

    try:
        # Открываем COM-порт
        ser = serial.Serial(PORT, int(BAUDRATE), timeout=2)
        print(f"Порт {PORT} открыт, скорость {BAUDRATE}.")
    except serial.SerialException as e:
        print(f"Ошибка: Не удалось открыть порт {PORT}. {e}")
        return

    # --- ШАГ 1: Идентификация устройства ---
    print("\n--- Шаг 1: Отправка команды идентификации (00 00) ---")
    
    # Создаем запрос
    request_packet = create_request(DEVICE_ADDRESS, 0x00, 0x00)
    print(f"Отправляем пакет: {' '.join(f'{b:02X}' for b in request_packet)}")

    # Отправляем и читаем ответ
    ser.write(request_packet)
    time.sleep(0.5) # Даем прибору время на ответ
    response_bytes = ser.read(128) # Читаем до 128 байт

    if not response_bytes:
        print("!!! Устройство не ответило. Проверьте подключение, адрес и скорость.")
        ser.close()
        return
        
    print(f"Получен ответ: {' '.join(f'{b:02X}' for b in response_bytes)}")

    # --- ШАГ 2: Разбор ответа и определение модели ---
    print("\n--- Шаг 2: Разбор ответа ---")
    parsed = parse_response(response_bytes)

    if parsed:
        print("Ответ корректен! Контрольная сумма верна.")
        try:
            # Декодируем данные (имя прибора) из ASCII
            device_name = parsed["data"].decode('ascii')
            print(f"Имя устройства: {device_name}")
            
            if "M" in device_name:
                print("Определен протокол: ТЭМ-104М (новый)")
            else:
                print("Определен протокол: ТЭМ-104 (старый)")
        except UnicodeDecodeError:
            print("Не удалось декодировать имя устройства.")
    else:
        print("!!! Получен некорректный ответ от устройства.")

    # Закрываем порт
    ser.close()
    print(f"\nПорт {PORT} закрыт.")

if __name__ == "__main__":
    main()

